{"posts":[{"title":"关于我","text":"我是谁一个程序员主要关注哪些技术 虚拟化NVMe 设备数据库，存储技术","link":"/2023/09/06/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"title":"SPDK 中的NVMe over PCIe驱动","text":"SPDK 是什么？ SPDK 是Intel推出的高性能用户态存储软件库SPDK。该软件库的核心是实现了用户态、异步、无锁、轮询方式的 NVMe 驱动。本文将结合代码分析 SPDK是如何在用户态实现这个高性能NVMe 驱动的。 SPDK NVMe 驱动详解SPDK NVMe 驱动的基本结构 首先先来看一下 spdk 的基本组成结构，nvme 驱动的代码主要位于 /lib/nvme 文件夹下。 最关键的一个数据结构 spdk_nvme_transport_ops，我们知道 NVMe 协议是一个应用层协议，其底层传输协议可以基于PCIe 或者 TCP 或者是RDMA，因此为了隐藏底层的实现细节，不同传输类型的NVMe设备驱动都需要实现这个结构体。接下来我们分析基于 pcie 的nvme 驱动的主要实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109struct spdk_nvme_transport_ops { char name[SPDK_NVMF_TRSTRING_MAX_LEN + 1]; enum spdk_nvme_transport_type type; struct spdk_nvme_ctrlr *(*ctrlr_construct)(const struct spdk_nvme_transport_id *trid, const struct spdk_nvme_ctrlr_opts *opts, void *devhandle); int (*ctrlr_scan)(struct spdk_nvme_probe_ctx *probe_ctx, bool direct_connect); int (*ctrlr_destruct)(struct spdk_nvme_ctrlr *ctrlr); int (*ctrlr_enable)(struct spdk_nvme_ctrlr *ctrlr); int (*ctrlr_set_reg_4)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, uint32_t value); int (*ctrlr_set_reg_8)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, uint64_t value); int (*ctrlr_get_reg_4)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, uint32_t *value); int (*ctrlr_get_reg_8)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, uint64_t *value); int (*ctrlr_set_reg_4_async)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, uint32_t value, spdk_nvme_reg_cb cb_fn, void *cb_arg); int (*ctrlr_set_reg_8_async)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, uint64_t value, spdk_nvme_reg_cb cb_fn, void *cb_arg); int (*ctrlr_get_reg_4_async)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, spdk_nvme_reg_cb cb_fn, void *cb_arg); int (*ctrlr_get_reg_8_async)(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, spdk_nvme_reg_cb cb_fn, void *cb_arg); uint32_t (*ctrlr_get_max_xfer_size)(struct spdk_nvme_ctrlr *ctrlr); uint16_t (*ctrlr_get_max_sges)(struct spdk_nvme_ctrlr *ctrlr); int (*ctrlr_reserve_cmb)(struct spdk_nvme_ctrlr *ctrlr); void *(*ctrlr_map_cmb)(struct spdk_nvme_ctrlr *ctrlr, size_t *size); int (*ctrlr_unmap_cmb)(struct spdk_nvme_ctrlr *ctrlr); int (*ctrlr_enable_pmr)(struct spdk_nvme_ctrlr *ctrlr); int (*ctrlr_disable_pmr)(struct spdk_nvme_ctrlr *ctrlr); void *(*ctrlr_map_pmr)(struct spdk_nvme_ctrlr *ctrlr, size_t *size); int (*ctrlr_unmap_pmr)(struct spdk_nvme_ctrlr *ctrlr); struct spdk_nvme_qpair *(*ctrlr_create_io_qpair)(struct spdk_nvme_ctrlr *ctrlr, uint16_t qid, const struct spdk_nvme_io_qpair_opts *opts); int (*ctrlr_delete_io_qpair)(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair); int (*ctrlr_connect_qpair)(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair); void (*ctrlr_disconnect_qpair)(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair); void (*qpair_abort_reqs)(struct spdk_nvme_qpair *qpair, uint32_t dnr); int (*qpair_reset)(struct spdk_nvme_qpair *qpair); int (*qpair_submit_request)(struct spdk_nvme_qpair *qpair, struct nvme_request *req); int32_t (*qpair_process_completions)(struct spdk_nvme_qpair *qpair, uint32_t max_completions); int (*qpair_iterate_requests)(struct spdk_nvme_qpair *qpair, int (*iter_fn)(struct nvme_request *req, void *arg), void *arg); void (*admin_qpair_abort_aers)(struct spdk_nvme_qpair *qpair); struct spdk_nvme_transport_poll_group *(*poll_group_create)(void); struct spdk_nvme_transport_poll_group *(*qpair_get_optimal_poll_group)( struct spdk_nvme_qpair *qpair); int (*poll_group_add)(struct spdk_nvme_transport_poll_group *tgroup, struct spdk_nvme_qpair *qpair); int (*poll_group_remove)(struct spdk_nvme_transport_poll_group *tgroup, struct spdk_nvme_qpair *qpair); int (*poll_group_connect_qpair)(struct spdk_nvme_qpair *qpair); int (*poll_group_disconnect_qpair)(struct spdk_nvme_qpair *qpair); int64_t (*poll_group_process_completions)(struct spdk_nvme_transport_poll_group *tgroup, uint32_t completions_per_qpair, spdk_nvme_disconnected_qpair_cb disconnected_qpair_cb); int (*poll_group_destroy)(struct spdk_nvme_transport_poll_group *tgroup); int (*poll_group_get_stats)(struct spdk_nvme_transport_poll_group *tgroup, struct spdk_nvme_transport_poll_group_stat **stats); void (*poll_group_free_stats)(struct spdk_nvme_transport_poll_group *tgroup, struct spdk_nvme_transport_poll_group_stat *stats); int (*ctrlr_get_memory_domains)(const struct spdk_nvme_ctrlr *ctrlr, struct spdk_memory_domain **domains, int array_size); int (*ctrlr_ready)(struct spdk_nvme_ctrlr *ctrlr); volatile struct spdk_nvme_registers *(*ctrlr_get_registers)(struct spdk_nvme_ctrlr *ctrlr);} nvme_pcie_ctrlr_construct 1234static intnvme_pcie_ctrlr_scan(struct spdk_nvme_probe_ctx *probe_ctx, bool direct_connect)","link":"/2023/09/07/SPDK-%E4%B8%AD%E7%9A%84NVMe-over-PCIe%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux， NVMe","slug":"Linux，-NVMe","link":"/tags/Linux%EF%BC%8C-NVMe/"}],"categories":[],"pages":[]}